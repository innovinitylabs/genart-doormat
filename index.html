<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Doormat Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            text-align: center;
            max-width: 1400px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #A0522D;
        }

        .seed-input {
            padding: 8px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            font-size: 14px;
            width: 100px;
        }

        .text-input {
            padding: 8px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            font-size: 14px;
            width: 200px;
            margin: 0 10px;
        }

        .slider-controls {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .slider-controls label {
            color: #333;
            font-weight: bold;
            font-size: 14px;
        }

        .slider-controls input[type="range"] {
            width: 200px;
            height: 6px;
            background: #ddd;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        .slider-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #8B4513;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-controls input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #8B4513;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .canvas-container {
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border-radius: 8px;
            overflow: hidden;
            background: white;
            display: inline-block;
            width: 1320px; /* doormatHeight + (fringeLength * 4) = 1200 + 120 = 1320 */
            height: 920px; /* doormatWidth + (fringeLength * 4) = 800 + 120 = 920 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Generative Doormat Art</h1>
        <p class="description">
            A P5.js generative art piece inspired by traditional woven doormats.<br>
            Each generation creates unique stripe patterns, colors, and textures with fringe details.
        </p>

        <div class="controls">
            <button onclick="generateNew()">Generate New Doormat</button>
            <button onclick="saveDoormat()">Save as Image</button>
            <input type="number" id="seedInput" class="seed-input" placeholder="Seed" value="42">
            <button onclick="generateFromSeed()">Use Seed</button>
            <button onclick="exportNFT()">Export NFT</button>
        </div>

        <div class="controls">
            <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label style="font-size: 12px; width: 60px;">Row 1:</label>
                    <input type="text" id="textInput1" class="text-input" placeholder="Enter text (A-Z, 0-9, space)" maxlength="11" oninput="validateTextInput(this)">
                </div>
                <div id="additionalRows" style="display: none;">
                    <!-- Additional rows will be added here dynamically -->
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="toggleRowsBtn" onclick="toggleAdditionalRows()" style="background-color: #4CAF50; font-size: 12px; padding: 8px 16px;">
                        + Add More Rows
                    </button>
                    <button onclick="addTextToDoormat()">Add Text</button>
                    <button onclick="clearText()">Clear Text</button>
                </div>
            </div>
        </div>



        <div class="canvas-container" id="canvas-container">
            <!-- P5.js canvas will be inserted here -->
        </div>

        <div class="palette-display" style="margin: 20px 0; text-align: center;">
            <h3 style="margin: 0 0 10px 0; color: #333;">Current Color Palette</h3>
            <div id="paletteName" style="font-weight: bold; color: #666; margin-bottom: 10px;">Loading...</div>
            <div id="colorSwatches" style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; max-width: 600px; margin: 0 auto;">
                <!-- Color swatches will be displayed here -->
            </div>
        </div>

        <div class="traits-display" style="margin: 20px 0; text-align: center; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h3 style="margin: 0 0 15px 0; color: #333;">NFT Traits</h3>
            <div id="traitsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; text-align: left;">
                <!-- Traits will be displayed here -->
            </div>
        </div>

        <p class="description">
            <strong>Instructions:</strong><br>
            • Click "Generate New Doormat" for a random pattern<br>
            • Enter a seed number and click "Use Seed" for reproducible results<br>
            • Enter text to embed it into the doormat pattern (max 11 characters, A-Z, 0-9, space only)<br>
            • Click "Save as Image" to download your doormat
        </p>
    </div>

    <script src="color-palettes.js"></script>
    <script src="doormat.js"></script>

    <script>
        function generateNew() {
            const seed = Math.floor(Math.random() * 10000);
            document.getElementById('seedInput').value = seed;
            generateDoormat(seed);

            // Update palette and traits display after a short delay to ensure the sketch has updated
            setTimeout(() => {
                if (typeof window.updatePaletteDisplay === 'function' && typeof window.getCurrentPalette === 'function') {
                    const currentPalette = window.getCurrentPalette();
                    if (currentPalette) {
                        window.updatePaletteDisplay(currentPalette.name, currentPalette.colors);
                    }
                }
                // Force traits update as backup
                updateTraitsFromSketch();
            }, 150);
        }

        function generateFromSeed() {
            const seed = parseInt(document.getElementById('seedInput').value) || 42;
            generateDoormat(seed);

            // Update palette and traits display after a short delay to ensure the sketch has updated
            setTimeout(() => {
                if (typeof window.updatePaletteDisplay === 'function' && typeof window.getCurrentPalette === 'function') {
                    const currentPalette = window.getCurrentPalette();
                    if (currentPalette) {
                        window.updatePaletteDisplay(currentPalette.name, currentPalette.colors);
                    }
                }
                // Force traits update as backup
                updateTraitsFromSketch();
            }, 150);
        }

        function saveDoormat() {
            saveCanvas('doormat-' + Date.now(), 'png');
        }



        function addTextToDoormat() {
            const textRows = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input) {
                    const text = input.value.trim();
                    if (text) {
                        textRows.push(text);
                    }
                }
            }
            if (textRows.length > 0 && typeof window.addTextToDoormatInSketch === 'function') {
                window.addTextToDoormatInSketch(textRows);
            }
        }

        let currentRowCount = 1; // Track how many rows are currently visible

        function toggleAdditionalRows() {
            if (currentRowCount < 5) {
                addRow();
            } else {
                // Hide all additional rows
                const additionalRows = document.getElementById('additionalRows');
                additionalRows.innerHTML = '';
                additionalRows.style.display = 'none';
                currentRowCount = 1;

                const toggleBtn = document.getElementById('toggleRowsBtn');
                toggleBtn.textContent = '+ Add More Rows';
                toggleBtn.style.backgroundColor = '#4CAF50';

                // Clear all additional row inputs
                for (let i = 2; i <= 5; i++) {
                    const input = document.getElementById('textInput' + i);
                    if (input) input.value = '';
                }
            }
        }

        function addRow() {
            if (currentRowCount >= 5) return; // Maximum 5 rows

            currentRowCount++;
            const additionalRows = document.getElementById('additionalRows');

            // Create new row element
            const newRow = document.createElement('div');
            newRow.style.display = 'flex';
            newRow.style.gap = '5px';
            newRow.style.alignItems = 'center';
            newRow.id = 'row' + currentRowCount;

            newRow.innerHTML = `
                <label style="font-size: 12px; width: 60px;">Row ${currentRowCount}:</label>
                <input type="text" id="textInput${currentRowCount}" class="text-input" placeholder="Enter text (A-Z, 0-9, space)" maxlength="11" oninput="validateTextInput(this)">
                <button onclick="removeRow(${currentRowCount})" style="background-color: #f44336; font-size: 10px; padding: 4px 8px;">×</button>
            `;

            additionalRows.appendChild(newRow);
            additionalRows.style.display = 'block';

            // Update button text
            updateAddRowButton();
        }

        function removeRow(rowNumber) {
            if (rowNumber <= 1) return; // Can't remove first row

            const rowElement = document.getElementById('row' + rowNumber);
            if (rowElement) {
                rowElement.remove();
                currentRowCount--;

                // Clear the input value
                const input = document.getElementById('textInput' + rowNumber);
                if (input) input.value = '';

                // Update button text and hide container if no additional rows
                updateAddRowButton();
            }
        }

        function updateAddRowButton() {
            const toggleBtn = document.getElementById('toggleRowsBtn');

            if (currentRowCount >= 5) {
                toggleBtn.textContent = '− Hide All Rows';
                toggleBtn.style.backgroundColor = '#f44336';
            } else {
                toggleBtn.textContent = '+ Add Row';
                toggleBtn.style.backgroundColor = '#4CAF50';
            }
        }

        function clearText() {
            // Clear all input values
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input) input.value = '';
            }

            // Remove all additional rows and reset to single row
            const additionalRows = document.getElementById('additionalRows');
            additionalRows.innerHTML = '';
            additionalRows.style.display = 'none';

            // Reset row count and button
            currentRowCount = 1;
            updateAddRowButton();

            if (typeof window.clearTextFromDoormat === 'function') {
                window.clearTextFromDoormat();
            }
        }

        function validateTextInput(input) {
            // Remove any characters that are not A-Z, 0-9, or space
            input.value = input.value.replace(/[^A-Za-z0-9\s]/g, '');
            // Convert to uppercase
            input.value = input.value.toUpperCase();
        }

        // Function to update the palette display
        function updatePaletteDisplay(paletteName, colors) {
            const nameElement = document.getElementById('paletteName');
            const swatchesElement = document.getElementById('colorSwatches');

            if (nameElement && swatchesElement) {
                nameElement.textContent = paletteName;

                // Clear existing swatches
                swatchesElement.innerHTML = '';

                // Create color swatches
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.style.cssText = `
                        width: 40px;
                        height: 40px;
                        background-color: ${color};
                        border: 2px solid #333;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: transform 0.2s;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    `;

                    // Add hover effect
                    swatch.addEventListener('mouseenter', () => {
                        swatch.style.transform = 'scale(1.1)';
                    });

                    swatch.addEventListener('mouseleave', () => {
                        swatch.style.transform = 'scale(1)';
                    });

                    // Add click to copy functionality
                    swatch.addEventListener('click', () => {
                        navigator.clipboard.writeText(color).then(() => {
                            // Show a brief "copied" message
                            const originalColor = swatch.style.backgroundColor;
                            swatch.style.backgroundColor = '#4CAF50';
                            swatch.style.borderColor = '#4CAF50';
                            setTimeout(() => {
                                swatch.style.backgroundColor = originalColor;
                                swatch.style.borderColor = '#333';
                            }, 500);
                        });
                    });

                    // Add tooltip with color code
                    swatch.title = `Click to copy: ${color}`;

                    swatchesElement.appendChild(swatch);
                });
            }
        }

        // Function to update the traits display
        function updateTraitsDisplay(traits) {
            const traitsContainer = document.getElementById('traitsContainer');

            if (traitsContainer && traits) {
                // Clear existing traits
                traitsContainer.innerHTML = '';

                // Create trait cards
                const traitItems = [
                    { label: 'Text Lines', value: traits.textLines, rarity: getTextLinesRarity(traits.textLines) },
                    { label: 'Total Characters', value: traits.totalCharacters, rarity: getCharacterRarity(traits.totalCharacters) },
                    { label: 'Palette Name', value: traits.paletteName, rarity: traits.paletteRarity },
                    { label: 'Palette Rarity', value: traits.paletteRarity, rarity: traits.paletteRarity },
                    { label: 'Stripe Count', value: traits.stripeCount, rarity: getStripeCountRarity(traits.stripeCount) },
                    { label: 'Stripe Complexity', value: traits.stripeComplexity, rarity: getStripeComplexityRarity(traits.stripeComplexity) }
                ];

                traitItems.forEach(trait => {
                    const traitCard = document.createElement('div');
                    traitCard.style.cssText = `
                        background: #f8f9fa;
                        border: 1px solid #dee2e6;
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        flex-direction: column;
                        gap: 5px;
                    `;

                    const rarityColor = getRarityColor(trait.rarity);

                    traitCard.innerHTML = `
                        <div style="font-weight: bold; color: #333; font-size: 14px;">${trait.label}</div>
                        <div style="color: #666; font-size: 16px;">${trait.value}</div>
                        <div style="color: ${rarityColor}; font-weight: bold; font-size: 12px; text-transform: uppercase;">${trait.rarity}</div>
                    `;

                    traitsContainer.appendChild(traitCard);
                });
            }
        }

        // Helper functions for rarity calculation
        function getTextLinesRarity(lines) {
            if (lines >= 5) return "Legendary";
            if (lines >= 4) return "Epic";
            if (lines >= 3) return "Rare";
            if (lines >= 2) return "Uncommon";
            return "Common";
        }

        function getCharacterRarity(chars) {
            if (chars >= 40) return "Legendary";
            if (chars >= 30) return "Epic";
            if (chars >= 20) return "Rare";
            if (chars >= 10) return "Uncommon";
            return "Common";
        }

        function getStripeComplexityRarity(complexity) {
            switch(complexity) {
                case 'Very Complex': return "Legendary";
                case 'Complex': return "Epic";
                case 'Moderate': return "Rare";
                case 'Simple': return "Uncommon";
                case 'Basic': return "Common";
                default: return "Common";
            }
        }

        function getStripeCountRarity(count) {
            if (count >= 40) return "Legendary";
            if (count >= 32) return "Epic";
            if (count >= 25) return "Rare";
            if (count >= 18) return "Uncommon";
            return "Common";
        }

        function getRarityColor(rarity) {
            switch(rarity) {
                case 'Legendary': return '#ff6b35';
                case 'Epic': return '#9b59b6';
                case 'Rare': return '#3498db';
                case 'Uncommon': return '#2ecc71';
                case 'Common': return '#95a5a6';
                default: return '#666';
            }
        }

        // Function to update traits from the sketch
        function updateTraitsFromSketch() {
            console.log("updateTraitsFromSketch called");
            if (typeof window.calculateTraits === 'function') {
                console.log("calculateTraits function found");
                const traits = window.calculateTraits();
                console.log("About to update traits display with:", traits);
                updateTraitsDisplay(traits);
            } else {
                console.log("calculateTraits function not found");
            }
        }

        // Generate initial doormat
        window.addEventListener('load', () => {
            generateFromSeed();
            // Update traits after initial generation
            setTimeout(() => {
                updateTraitsFromSketch();
            }, 200);
        });

        // Make the functions globally available for the P5.js sketch
        window.updatePaletteDisplay = updatePaletteDisplay;
        window.updateTraitsFromSketch = updateTraitsFromSketch;

        // Function to create clean working doormat code
        function createCleanDoormatCode(currentPalette, currentStripeData, textRows) {
            const seed = document.getElementById('seedInput').value;
            
            // Create clean, working doormat code
            const cleanCode = `
let doormatWidth = 800;
let doormatHeight = 1200;
let fringeLength = 30;
let weftThickness = 8;
let selectedPalette = ${JSON.stringify(currentPalette)};
let stripeData = ${JSON.stringify(currentStripeData)};
let doormatTextRows = ${JSON.stringify(textRows)};
let textData = [];

function setup() {
    let totalWidth = doormatWidth + fringeLength * 4;
    let totalHeight = doormatHeight + fringeLength * 4;
    createCanvas(totalHeight, totalWidth);
    pixelDensity(1);
    noLoop();
    
    randomSeed(${seed});
    noiseSeed(${seed});
    
    generateDoormat();
}

function generateDoormat() {
    background(26);
    
    push();
    translate(width/2, height/2);
    rotate(PI/2);
    translate(-height/2, -width/2);
    
    drawStripes();
    if (doormatTextRows.length > 0) {
        generateTextData();
        drawText();
    }
    drawFringe();
    drawSelvedgeEdges();
    
    pop();
}

function drawStripes() {
    stripeData.forEach(stripe => {
        fill(stripe.colors[0]);
        noStroke();
        rect(fringeLength, stripe.y + fringeLength, doormatWidth, stripe.height);
    });
}

function generateTextData() {
    textData = [];
    doormatTextRows.forEach((text, rowIndex) => {
        let startY = fringeLength + 150 + rowIndex * 100;
        for (let i = 0; i < text.length; i++) {
            let charX = fringeLength + 100 + i * 50;
            textData.push({x: charX, y: startY, char: text[i]});
        }
    });
}

function drawText() {
    textData.forEach(item => {
        fill(255);
        noStroke();
        rect(item.x, item.y, 40, 70);
    });
}

function drawFringe() {
    for (let i = 0; i < 50; i++) {
        let x = random(fringeLength, fringeLength + doormatWidth);
        let color = stripeData[floor(map(x - fringeLength, 0, doormatWidth, 0, stripeData.length))]?.colors[0] || selectedPalette.colors[0];
        stroke(color);
        strokeWeight(2);
        line(x, 0, x, fringeLength);
        line(x, fringeLength + doormatHeight, x, fringeLength + doormatHeight + fringeLength);
    }
}

function drawSelvedgeEdges() {
    stripeData.forEach((stripe, i) => {
        let y = stripe.y + fringeLength;
        let color = stripe.colors[0];
        stroke(color);
        strokeWeight(2);
        arc(fringeLength - 15, y + stripe.height/2, 30, 30, PI/2, 3*PI/2);
        arc(fringeLength + doormatWidth + 15, y + stripe.height/2, 30, 30, -PI/2, PI/2);
    });
}`;

            return cleanCode;
        }

        async function exportNFT() {
            // Get current state
            const seed = document.getElementById('seedInput').value;
            const textRows = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input && input.value.trim()) {
                    textRows.push(input.value.trim());
                }
            }
            
            // Get current palette and traits
            const palette = window.getCurrentPalette();
            const traits = window.calculateTraits();
            
            // Get current stripe data from the live sketch
            const currentStripeData = window.stripeData || [];
            
            try {
                // Create clean working doormat code with current state
                const cleanDoormatCode = createCleanDoormatCode(palette, currentStripeData, textRows);
                
                // Create self-contained NFT HTML with P5.js from CDN  
                let nftHTML = '<!DOCTYPE html>';
                nftHTML += '<html><head><meta charset="UTF-8">';
                nftHTML += '<title>Doormat NFT #' + seed + '</title>';
                nftHTML += '<style>';
                nftHTML += 'body{margin:0;padding:0;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:100vh;font-family:Arial,sans-serif}';
                nftHTML += 'canvas{border-radius:8px;box-shadow:0 4px 8px rgba(255,255,255,0.1)}';
                nftHTML += '.info{position:absolute;top:10px;left:10px;color:#fff;font-size:10px;opacity:0.7}';
                nftHTML += '.traits{position:absolute;top:10px;right:10px;color:#fff;font-size:8px;opacity:0.7;text-align:right}';
                nftHTML += '</style>';
                nftHTML += '<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></' + 'script>';
                nftHTML += '</head><body>';
                nftHTML += '<div class="info">Seed: ' + seed + '<br>Palette: ' + palette.name + '</div>';
                nftHTML += '<div class="traits">';
                nftHTML += Object.entries(traits).map(function(entry) { return entry[0] + ': ' + entry[1]; }).join('<br>');
                nftHTML += '</div>';
                nftHTML += '<div id="canvas-container"></div>';
                nftHTML += '<script>';
                nftHTML += cleanDoormatCode;
                nftHTML += '</' + 'script>';
                nftHTML += '</body></html>';
                
                // Download the self-contained file
                const blob = new Blob([nftHTML], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'doormat-nft-' + seed + '.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('NFT file size:', Math.round(nftHTML.length / 1024) + 'KB');
                alert('NFT HTML exported! File size: ' + Math.round(nftHTML.length / 1024) + 'KB - ready for on-chain storage.');
                
            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
            }
        }
    </script>
</body>
</html>
