<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Doormat Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            text-align: center;
            max-width: 1400px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #A0522D;
        }

        .seed-input {
            padding: 8px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            font-size: 14px;
            width: 100px;
        }

        .text-input {
            padding: 8px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            font-size: 14px;
            width: 200px;
            margin: 0 10px;
        }

        .slider-controls {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .slider-controls label {
            color: #333;
            font-weight: bold;
            font-size: 14px;
        }

        .slider-controls input[type="range"] {
            width: 200px;
            height: 6px;
            background: #ddd;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        .slider-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #8B4513;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-controls input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #8B4513;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .canvas-container {
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border-radius: 8px;
            overflow: hidden;
            background: white;
            display: inline-block;
            width: 1320px; /* doormatHeight + (fringeLength * 4) = 1200 + 120 = 1320 */
            height: 920px; /* doormatWidth + (fringeLength * 4) = 800 + 120 = 920 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Generative Doormat Art</h1>
        <p class="description">
            A P5.js generative art piece inspired by traditional woven doormats.<br>
            Each generation creates unique stripe patterns, colors, and textures with fringe details.
        </p>

        <div class="controls">
            <button onclick="generateNew()">Generate New Doormat</button>
            <button onclick="saveDoormat()">Save as Image</button>
            <input type="number" id="seedInput" class="seed-input" placeholder="Seed" value="42">
            <button onclick="generateFromSeed()">Use Seed</button>
            <button onclick="exportNFT()">Export NFT</button>
        </div>

        <div class="controls">
            <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label style="font-size: 12px; width: 60px;">Row 1:</label>
                    <input type="text" id="textInput1" class="text-input" placeholder="Enter text (A-Z, 0-9, space)" maxlength="11" oninput="validateTextInput(this)">
                </div>
                <div id="additionalRows" style="display: none;">
                    <!-- Additional rows will be added here dynamically -->
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="toggleRowsBtn" onclick="toggleAdditionalRows()" style="background-color: #4CAF50; font-size: 12px; padding: 8px 16px;">
                        + Add More Rows
                    </button>
                    <button onclick="addTextToDoormat()">Add Text</button>
                    <button onclick="clearText()">Clear Text</button>
                </div>
            </div>
        </div>



        <div class="canvas-container" id="canvas-container">
            <!-- P5.js canvas will be inserted here -->
        </div>

        <div class="palette-display" style="margin: 20px 0; text-align: center;">
            <h3 style="margin: 0 0 10px 0; color: #333;">Current Color Palette</h3>
            <div id="paletteName" style="font-weight: bold; color: #666; margin-bottom: 10px;">Loading...</div>
            <div id="colorSwatches" style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; max-width: 600px; margin: 0 auto;">
                <!-- Color swatches will be displayed here -->
            </div>
        </div>

        <div class="traits-display" style="margin: 20px 0; text-align: center; max-width: 800px; margin-left: auto; margin-right: auto;">
            <h3 style="margin: 0 0 15px 0; color: #333;">NFT Traits</h3>
            <div id="traitsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; text-align: left;">
                <!-- Traits will be displayed here -->
            </div>
        </div>

        <p class="description">
            <strong>Instructions:</strong><br>
            • Click "Generate New Doormat" for a random pattern<br>
            • Enter a seed number and click "Use Seed" for reproducible results<br>
            • Enter text to embed it into the doormat pattern (max 11 characters, A-Z, 0-9, space only)<br>
            • Click "Save as Image" to download your doormat
        </p>
    </div>

    <script src="color-palettes.js"></script>
    <script src="character-map.js"></script>
    <script src="trait-calculator.js"></script>
    <script src="doormat.js"></script>
    <script src="html-interface.js"></script>

    <script>
        function generateNew() {
            const seed = Math.floor(Math.random() * 10000);
            document.getElementById('seedInput').value = seed;
            generateDoormat(seed);

            // Update palette and traits display after a short delay to ensure the sketch has updated
            setTimeout(() => {
                if (typeof window.updatePaletteDisplay === 'function' && typeof window.getCurrentPalette === 'function') {
                    const currentPalette = window.getCurrentPalette();
                    if (currentPalette) {
                        window.updatePaletteDisplay(currentPalette.name, currentPalette.colors);
                    }
                }
                // Force traits update as backup
                updateTraitsFromSketch();
            }, 150);
        }

        function generateFromSeed() {
            const seed = parseInt(document.getElementById('seedInput').value) || 42;
            generateDoormat(seed);

            // Update palette and traits display after a short delay to ensure the sketch has updated
            setTimeout(() => {
                if (typeof window.updatePaletteDisplay === 'function' && typeof window.getCurrentPalette === 'function') {
                    const currentPalette = window.getCurrentPalette();
                    if (currentPalette) {
                        window.updatePaletteDisplay(currentPalette.name, currentPalette.colors);
                    }
                }
                // Force traits update as backup
                updateTraitsFromSketch();
            }, 150);
        }

        function saveDoormat() {
            saveCanvas('doormat-' + Date.now(), 'png');
        }



        function addTextToDoormat() {
            const textRows = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input) {
                    const text = input.value.trim();
                    if (text) {
                        textRows.push(text);
                    }
                }
            }
            if (textRows.length > 0 && typeof window.addTextToDoormatInSketch === 'function') {
                window.addTextToDoormatInSketch(textRows);
            }
        }

        let currentRowCount = 1; // Track how many rows are currently visible

        function toggleAdditionalRows() {
            if (currentRowCount < 5) {
                addRow();
            } else {
                // Hide all additional rows
                const additionalRows = document.getElementById('additionalRows');
                additionalRows.innerHTML = '';
                additionalRows.style.display = 'none';
                currentRowCount = 1;

                const toggleBtn = document.getElementById('toggleRowsBtn');
                toggleBtn.textContent = '+ Add More Rows';
                toggleBtn.style.backgroundColor = '#4CAF50';

                // Clear all additional row inputs
                for (let i = 2; i <= 5; i++) {
                    const input = document.getElementById('textInput' + i);
                    if (input) input.value = '';
                }
            }
        }

        function addRow() {
            if (currentRowCount >= 5) return; // Maximum 5 rows

            currentRowCount++;
            const additionalRows = document.getElementById('additionalRows');

            // Create new row element
            const newRow = document.createElement('div');
            newRow.style.display = 'flex';
            newRow.style.gap = '5px';
            newRow.style.alignItems = 'center';
            newRow.id = 'row' + currentRowCount;

            newRow.innerHTML = `
                <label style="font-size: 12px; width: 60px;">Row ${currentRowCount}:</label>
                <input type="text" id="textInput${currentRowCount}" class="text-input" placeholder="Enter text (A-Z, 0-9, space)" maxlength="11" oninput="validateTextInput(this)">
                <button onclick="removeRow(${currentRowCount})" style="background-color: #f44336; font-size: 10px; padding: 4px 8px;">×</button>
            `;

            additionalRows.appendChild(newRow);
            additionalRows.style.display = 'block';

            // Update button text
            updateAddRowButton();
        }

        function removeRow(rowNumber) {
            if (rowNumber <= 1) return; // Can't remove first row

            const rowElement = document.getElementById('row' + rowNumber);
            if (rowElement) {
                rowElement.remove();
                currentRowCount--;

                // Clear the input value
                const input = document.getElementById('textInput' + rowNumber);
                if (input) input.value = '';

                // Update button text and hide container if no additional rows
                updateAddRowButton();
            }
        }

        function updateAddRowButton() {
            const toggleBtn = document.getElementById('toggleRowsBtn');

            if (currentRowCount >= 5) {
                toggleBtn.textContent = '− Hide All Rows';
                toggleBtn.style.backgroundColor = '#f44336';
            } else {
                toggleBtn.textContent = '+ Add Row';
                toggleBtn.style.backgroundColor = '#4CAF50';
            }
        }

        function clearText() {
            // Clear all input values
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input) input.value = '';
            }

            // Remove all additional rows and reset to single row
            const additionalRows = document.getElementById('additionalRows');
            additionalRows.innerHTML = '';
            additionalRows.style.display = 'none';

            // Reset row count and button
            currentRowCount = 1;
            updateAddRowButton();

            if (typeof window.clearTextFromDoormat === 'function') {
                window.clearTextFromDoormat();
            }
        }

        function validateTextInput(input) {
            // Remove any characters that are not A-Z, 0-9, or space
            input.value = input.value.replace(/[^A-Za-z0-9\s]/g, '');
            // Convert to uppercase
            input.value = input.value.toUpperCase();
        }

        // Function to update the palette display
        function updatePaletteDisplay(paletteName, colors) {
            const nameElement = document.getElementById('paletteName');
            const swatchesElement = document.getElementById('colorSwatches');

            if (nameElement && swatchesElement) {
                nameElement.textContent = paletteName;

                // Clear existing swatches
                swatchesElement.innerHTML = '';

                // Create color swatches
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.style.cssText = `
                        width: 40px;
                        height: 40px;
                        background-color: ${color};
                        border: 2px solid #333;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: transform 0.2s;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    `;

                    // Add hover effect
                    swatch.addEventListener('mouseenter', () => {
                        swatch.style.transform = 'scale(1.1)';
                    });

                    swatch.addEventListener('mouseleave', () => {
                        swatch.style.transform = 'scale(1)';
                    });

                    // Add click to copy functionality
                    swatch.addEventListener('click', () => {
                        navigator.clipboard.writeText(color).then(() => {
                            // Show a brief "copied" message
                            const originalColor = swatch.style.backgroundColor;
                            swatch.style.backgroundColor = '#4CAF50';
                            swatch.style.borderColor = '#4CAF50';
                            setTimeout(() => {
                                swatch.style.backgroundColor = originalColor;
                                swatch.style.borderColor = '#333';
                            }, 500);
                        });
                    });

                    // Add tooltip with color code
                    swatch.title = `Click to copy: ${color}`;

                    swatchesElement.appendChild(swatch);
                });
            }
        }

        // Function to update the traits display
        function updateTraitsDisplay(traits) {
            const traitsContainer = document.getElementById('traitsContainer');

            if (traitsContainer && traits) {
                // Clear existing traits
                traitsContainer.innerHTML = '';

                // Create trait cards
                const traitItems = [
                    { label: 'Text Lines', value: traits.textLines, rarity: getTextLinesRarity(traits.textLines) },
                    { label: 'Total Characters', value: traits.totalCharacters, rarity: getCharacterRarity(traits.totalCharacters) },
                    { label: 'Palette Name', value: traits.paletteName, rarity: traits.paletteRarity },
                    { label: 'Palette Rarity', value: traits.paletteRarity, rarity: traits.paletteRarity },
                    { label: 'Stripe Count', value: traits.stripeCount, rarity: getStripeCountRarity(traits.stripeCount) },
                    { label: 'Stripe Complexity', value: traits.stripeComplexity, rarity: getStripeComplexityRarity(traits.stripeComplexity) }
                ];

                traitItems.forEach(trait => {
                    const traitCard = document.createElement('div');
                    traitCard.style.cssText = `
                        background: #f8f9fa;
                        border: 1px solid #dee2e6;
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        flex-direction: column;
                        gap: 5px;
                    `;

                    const rarityColor = getRarityColor(trait.rarity);

                    traitCard.innerHTML = `
                        <div style="font-weight: bold; color: #333; font-size: 14px;">${trait.label}</div>
                        <div style="color: #666; font-size: 16px;">${trait.value}</div>
                        <div style="color: ${rarityColor}; font-weight: bold; font-size: 12px; text-transform: uppercase;">${trait.rarity}</div>
                    `;

                    traitsContainer.appendChild(traitCard);
                });
            }
        }

        // Helper functions for rarity calculation
        function getTextLinesRarity(lines) {
            if (lines >= 5) return "Legendary";
            if (lines >= 4) return "Epic";
            if (lines >= 3) return "Rare";
            if (lines >= 2) return "Uncommon";
            return "Common";
        }

        function getCharacterRarity(chars) {
            if (chars >= 40) return "Legendary";
            if (chars >= 30) return "Epic";
            if (chars >= 20) return "Rare";
            if (chars >= 10) return "Uncommon";
            return "Common";
        }

        function getStripeComplexityRarity(complexity) {
            switch(complexity) {
                case 'Very Complex': return "Legendary";
                case 'Complex': return "Epic";
                case 'Moderate': return "Rare";
                case 'Simple': return "Uncommon";
                case 'Basic': return "Common";
                default: return "Common";
            }
        }

        function getStripeCountRarity(count) {
            if (count >= 40) return "Legendary";
            if (count >= 32) return "Epic";
            if (count >= 25) return "Rare";
            if (count >= 18) return "Uncommon";
            return "Common";
        }

        function getRarityColor(rarity) {
            switch(rarity) {
                case 'Legendary': return '#ff6b35';
                case 'Epic': return '#9b59b6';
                case 'Rare': return '#3498db';
                case 'Uncommon': return '#2ecc71';
                case 'Common': return '#95a5a6';
                default: return '#666';
            }
        }

        // Function to update traits from the sketch
        function updateTraitsFromSketch() {
            console.log("updateTraitsFromSketch called");
            if (typeof window.calculateTraits === 'function') {
                console.log("calculateTraits function found");
                const traits = window.calculateTraits();
                console.log("About to update traits display with:", traits);
                updateTraitsDisplay(traits);
            } else {
                console.log("calculateTraits function not found");
            }
        }

        // Generate initial doormat
        window.addEventListener('load', () => {
            generateFromSeed();
            // Update traits after initial generation
            setTimeout(() => {
                updateTraitsFromSketch();
            }, 200);
        });

        // Make the functions globally available for the P5.js sketch
        window.updatePaletteDisplay = updatePaletteDisplay;
        window.updateTraitsFromSketch = updateTraitsFromSketch;

        // Function to create clean working doormat code
        function createPureAlgorithmCode(seed, currentPalette, currentStripeData, textRows) {
            // Get only the characters actually used in text
            const usedChars = getUsedCharacters(textRows);
            
            // Create pure, self-contained algorithm
            const pureCode = `
// Doormat NFT #${seed} - Self-contained algorithm
let doormatWidth = 800;
let doormatHeight = 1200;
let fringeLength = 30;
let weftThickness = 8;
let warpThickness = 2;
const TEXT_SCALE = 2;

// Embedded current state
let selectedPalette = ${JSON.stringify(currentPalette)};
let stripeData = ${JSON.stringify(currentStripeData)};
let doormatTextRows = ${JSON.stringify(textRows)};
let textData = [];

// Text colors
let lightTextColor, darkTextColor;

// Embedded character map (only used characters)
const characterMap = ${JSON.stringify(usedChars)};

function updateTextColors() {
    if (!selectedPalette || !selectedPalette.colors) return;
    let darkest = selectedPalette.colors[0];
    let lightest = selectedPalette.colors[0];
    let darkestVal = 999, lightestVal = -1;
    for (let hex of selectedPalette.colors) {
        let c = color(hex);
        let bright = (red(c) + green(c) + blue(c)) / 3;
        if (bright < darkestVal) { darkestVal = bright; darkest = hex; }
        if (bright > lightestVal) { lightestVal = bright; lightest = hex; }
    }
    darkTextColor = color(darkest);
    lightTextColor = lerpColor(color(lightest), color(255), 0.3);
    darkTextColor = lerpColor(color(darkest), color(0), 0.4);
}

function setup() {
    let totalWidth = doormatWidth + fringeLength * 4;
    let totalHeight = doormatHeight + fringeLength * 4;
    createCanvas(totalHeight, totalWidth);
    pixelDensity(1);
    noLoop();
    
    randomSeed(${seed});
    noiseSeed(${seed});
    
    updateTextColors();
    generateTextData();
    
    draw();
}

function draw() {
    background(222, 222, 222);
    
    push();
    translate(width/2, height/2);
    rotate(PI/2);
    translate(-height/2, -width/2);
    
    push();
    translate(fringeLength * 2, fringeLength * 2);
    
    for (let stripe of stripeData) {
        drawStripe(stripe);
    }
    
    drawTextureOverlay();
    pop();
    
    drawFringe();
    drawSelvedgeEdges();
    
    pop();
}

${extractCoreAlgorithmFunctions()}
`;
            return pureCode;
        }

        function getUsedCharacters(textRows) {
            const used = new Set();
            textRows.forEach(row => {
                for (let char of row.toUpperCase()) {
                    used.add(char);
                }
            });
            used.add(' '); // Always include space
            
            const usedCharMap = {};
            used.forEach(char => {
                if (characterMap[char]) {
                    usedCharMap[char] = characterMap[char];
                }
            });
            return usedCharMap;
        }

        function extractCoreAlgorithmFunctions() {
            // This extracts the core rendering functions from our algorithm
            // We'll include the essential drawing functions here
            return `
function drawStripe(stripe) {
    let warpSpacing = warpThickness + 1;
    let weftSpacing = weftThickness + 1;
    
    for (let x = 0; x < doormatWidth; x += warpSpacing) {
        for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) {
            let warpColor = color(stripe.primaryColor);
            
            let isTextPixel = false;
            if (textData.length > 0) {
                for (let textPixel of textData) {
                    if (x >= textPixel.x && x < textPixel.x + textPixel.width &&
                        y >= textPixel.y && y < textPixel.y + textPixel.height) {
                        isTextPixel = true;
                        break;
                    }
                }
            }
            
            let r = red(warpColor) + random(-15, 15);
            let g = green(warpColor) + random(-15, 15);
            let b = blue(warpColor) + random(-15, 15);
            
            if (isTextPixel) {
                const bgBrightness = (r + g + b) / 3;
                let tc = bgBrightness < 128 ? lightTextColor : darkTextColor;
                r = red(tc); g = green(tc); b = blue(tc);
            }
            
            r = constrain(r, 0, 255);
            g = constrain(g, 0, 255);
            b = constrain(b, 0, 255);
            
            fill(r, g, b);
            noStroke();
            
            let warpCurve = sin(y * 0.05) * 0.5;
            rect(x + warpCurve, y, warpThickness, weftSpacing);
        }
    }
    
    for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) {
        for (let x = 0; x < doormatWidth; x += warpSpacing) {
            let weftColor = color(stripe.primaryColor);
            
            let isTextPixel = false;
            if (textData.length > 0) {
                for (let textPixel of textData) {
                    if (x >= textPixel.x && x < textPixel.x + textPixel.width &&
                        y >= textPixel.y && y < textPixel.y + textPixel.height) {
                        isTextPixel = true;
                        break;
                    }
                }
            }
            
            if (stripe.weaveType === 'mixed' && stripe.secondaryColor) {
                if (noise(x * 0.1, y * 0.1) > 0.5) {
                    weftColor = color(stripe.secondaryColor);
                }
            } else if (stripe.weaveType === 'textured') {
                let noiseVal = noise(x * 0.05, y * 0.05);
                weftColor = lerpColor(color(stripe.primaryColor), color(255), noiseVal * 0.15);
            }
            
            let r = red(weftColor) + random(-20, 20);
            let g = green(weftColor) + random(-20, 20);
            let b = blue(weftColor) + random(-20, 20);
            
            if (isTextPixel) {
                const bgBrightness = (r + g + b) / 3;
                let tc = bgBrightness < 128 ? lightTextColor : darkTextColor;
                r = red(tc); g = green(tc); b = blue(tc);
            }
            
            r = constrain(r, 0, 255);
            g = constrain(g, 0, 255);
            b = constrain(b, 0, 255);
            
            fill(r, g, b);
            noStroke();
            
            let weftCurve = cos(x * 0.05) * 0.5;
            rect(x, y + weftCurve, warpSpacing, weftThickness);
        }
    }
    
    for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing * 2) {
        for (let x = 0; x < doormatWidth; x += warpSpacing * 2) {
            fill(0, 0, 0, 40);
            noStroke();
            rect(x + 1, y + 1, warpSpacing - 2, weftSpacing - 2);
        }
    }
    
    for (let y = stripe.y + weftSpacing; y < stripe.y + stripe.height; y += weftSpacing * 2) {
        for (let x = warpSpacing; x < doormatWidth; x += warpSpacing * 2) {
            fill(255, 255, 255, 30);
            noStroke();
            rect(x, y, warpSpacing - 1, weftSpacing - 1);
        }
    }
}

function drawTextureOverlay() {
    push();
    blendMode(MULTIPLY);
    
    for (let x = 0; x < doormatWidth; x += 2) {
        for (let y = 0; y < doormatHeight; y += 2) {
            let noiseVal = noise(x * 0.02, y * 0.02);
            let hatchingIntensity = map(noiseVal, 0, 1, 0, 50);
            
            fill(0, 0, 0, hatchingIntensity);
            noStroke();
            rect(x, y, 2, 2);
        }
    }
    
    for (let x = 0; x < doormatWidth; x += 6) {
        for (let y = 0; y < doormatHeight; y += 6) {
            let reliefNoise = noise(x * 0.03, y * 0.03);
            if (reliefNoise > 0.6) {
                fill(255, 255, 255, 25);
                noStroke();
                rect(x, y, 6, 6);
            } else if (reliefNoise < 0.4) {
                fill(0, 0, 0, 20);
                noStroke();
                rect(x, y, 6, 6);
            }
        }
    }
    
    pop();
}

function drawFringe() {
    drawFringeSection(fringeLength * 2, fringeLength, doormatWidth, fringeLength, 'top');
    drawFringeSection(fringeLength * 2, fringeLength * 2 + doormatHeight, doormatWidth, fringeLength, 'bottom');
    drawSelvedgeEdges();
}

function drawSelvedgeEdges() {
    let weftSpacing = weftThickness + 1;
    let isFirstWeft = true;
    
    for (let stripe of stripeData) {
        for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) {
            if (isFirstWeft) {
                isFirstWeft = false;
                continue;
            }
            
            if (stripe === stripeData[stripeData.length - 1] && y + weftSpacing >= stripe.y + stripe.height) {
                continue;
            }
            
            let selvedgeColor = color(stripe.primaryColor);
            if (stripe.secondaryColor && stripe.weaveType === 'mixed') {
                let secondaryColor = color(stripe.secondaryColor);
                let blendFactor = noise(y * 0.1) * 0.5 + 0.5;
                selvedgeColor = lerpColor(selvedgeColor, secondaryColor, blendFactor);
            }
            
            let r = red(selvedgeColor) * 0.8;
            let g = green(selvedgeColor) * 0.8;
            let b = blue(selvedgeColor) * 0.8;
            
            fill(r, g, b);
            noStroke();
            
            let radius = weftThickness * random(1.2, 1.8);
            let centerX = fringeLength * 2 + random(-2, 2);
            let centerY = fringeLength * 2 + y + weftThickness/2 + random(-1, 1);
            
            let startAngle = HALF_PI + random(-0.2, 0.2);
            let endAngle = -HALF_PI + random(-0.2, 0.2);
            
            arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle);
            
            centerX = fringeLength * 2 + doormatWidth + random(-2, 2);
            startAngle = -HALF_PI + random(-0.2, 0.2);
            endAngle = HALF_PI + random(-0.2, 0.2);
            
            arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle);
        }
    }
}

function drawFringeSection(x, y, w, h, side) {
    let fringeStrands = w / 12;
    let strandWidth = w / fringeStrands;
    
    for (let i = 0; i < fringeStrands; i++) {
        let strandX = x + i * strandWidth;
        let strandColor = random(selectedPalette.colors);
        
        for (let j = 0; j < 12; j++) {
            let threadX = strandX + random(-strandWidth/6, strandWidth/6);
            let startY = side === 'top' ? y + h : y;
            let endY = side === 'top' ? y : y + h;
            
            let waveAmplitude = random(1, 4);
            let waveFreq = random(0.2, 0.8);
            let direction = random([-1, 1]);
            let curlIntensity = random(0.5, 2.0);
            let threadLength = random(0.8, 1.2);
            
            let fringeColor = color(strandColor);
            let r = red(fringeColor) * 0.7;
            let g = green(fringeColor) * 0.7;
            let b = blue(fringeColor) * 0.7;
            
            stroke(r, g, b);
            strokeWeight(random(0.5, 1.2));
            
            noFill();
            beginShape();
            for (let t = 0; t <= 1; t += 0.1) {
                let yPos = lerp(startY, endY, t * threadLength);
                let xOffset = sin(t * PI * waveFreq) * waveAmplitude * t * direction * curlIntensity;
                xOffset += random(-1, 1);
                if (random() < 0.3) {
                    xOffset += random(-2, 2);
                }
                vertex(threadX + xOffset, yPos);
            }
            endShape();
        }
    }
}

function generateTextData() {
    textData = [];
    if (!doormatTextRows || doormatTextRows.length === 0) return;
    
    const warpSpacing = warpThickness + 1;
    const weftSpacing = weftThickness + 1;
    const scaledWarp = warpSpacing * TEXT_SCALE;
    const scaledWeft = weftSpacing * TEXT_SCALE;
    
    const charWidth = 7 * scaledWarp;
    const charHeight = 5 * scaledWeft;
    const spacing = scaledWeft;
    const rowSpacing = charWidth * 1.5;
    
    const totalRowsWidth = doormatTextRows.length * charWidth + (doormatTextRows.length - 1) * rowSpacing;
    const baseStartX = (doormatWidth - totalRowsWidth) / 2;
    
    for (let rowIndex = 0; rowIndex < doormatTextRows.length; rowIndex++) {
        const doormatText = doormatTextRows[rowIndex];
        if (!doormatText) continue;
        
        const textHeight = doormatText.length * (charHeight + spacing) - spacing;
        const startX = baseStartX + rowIndex * (charWidth + rowSpacing);
        const startY = (doormatHeight - textHeight) / 2;
        
        for (let i = 0; i < doormatText.length; i++) {
            const char = doormatText.charAt(i);
            const charY = startY + (doormatText.length - 1 - i) * (charHeight + spacing);
            const charPixels = generateCharacterPixels(char, startX, charY, charWidth, charHeight);
            textData.push(...charPixels);
        }
    }
}

function generateCharacterPixels(char, x, y, width, height) {
    const pixels = [];
    const warpSpacing = warpThickness + 1;
    const weftSpacing = weftThickness + 1;
    const scaledWarp = warpSpacing * TEXT_SCALE;
    const scaledWeft = weftSpacing * TEXT_SCALE;

    const charDef = characterMap[char] || characterMap[' '];
    if (!charDef) return pixels;

    const numRows = charDef.length;
    const numCols = charDef[0].length;

    for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
            if (charDef[row][col] === '1') {
                const newCol = row;
                const newRow = numCols - 1 - col;
                pixels.push({
                    x: x + newCol * scaledWarp,
                    y: y + newRow * scaledWeft,
                    width: scaledWarp,
                    height: scaledWeft
                });
            }
        }
    }
    return pixels;
}`;
        }

        function minifyCode(code) {
            // Simple minification - remove comments, extra whitespace, and line breaks
            return code
                .replace(/\/\*[\s\S]*?\*\//g, '') // Remove /* */ comments
                .replace(/\/\/.*$/gm, '') // Remove // comments
                .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
                .replace(/;\s*}/g, ';}') // Remove space before closing braces
                .replace(/{\s*/g, '{') // Remove space after opening braces
                .replace(/}\s*/g, '}') // Remove space after closing braces
                .replace(/,\s*/g, ',') // Remove space after commas
                .replace(/;\s*/g, ';') // Remove space after semicolons
                .trim();
        }

        function obfuscateWithTamilLetters(code) {
            // Tamil letters for variable obfuscation
            const tamilLetters = ['அ','ஆ','இ','ஈ','உ','ஊ','எ','ஏ','ஐ','ஒ','ஓ','ஔ','க','ங','ச','ஜ','ஞ','ட','ண','த','ந','ப','ம','ய','ர','ல','வ','ஶ','ஷ','ஸ','ஹ'];
            
            // Common variable names to obfuscate
            const variables = [
                'doormatWidth', 'doormatHeight', 'fringeLength', 'weftThickness', 'warpThickness',
                'selectedPalette', 'stripeData', 'doormatTextRows', 'textData', 'lightTextColor', 'darkTextColor',
                'drawStripe', 'drawTextureOverlay', 'drawFringe', 'drawSelvedgeEdges', 'drawFringeSection',
                'generateTextData', 'generateCharacterPixels', 'updateTextColors',
                'warpSpacing', 'weftSpacing', 'isTextPixel', 'warpColor', 'weftColor', 'selvedgeColor',
                'fringeColor', 'charWidth', 'charHeight', 'scaledWarp', 'scaledWeft'
            ];
            
            let obfuscatedCode = code;
            let letterIndex = 0;
            
            variables.forEach(variable => {
                if (letterIndex < tamilLetters.length && obfuscatedCode.includes(variable)) {
                    const tamilVar = tamilLetters[letterIndex];
                    // Use word boundaries to avoid partial replacements
                    const regex = new RegExp('\\b' + variable + '\\b', 'g');
                    obfuscatedCode = obfuscatedCode.replace(regex, tamilVar);
                    letterIndex++;
                }
            });
            
            return obfuscatedCode;
        }

        async function exportNFT() {
            // Get current state
            const seed = document.getElementById('seedInput').value;
            const textRows = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById('textInput' + i);
                if (input && input.value.trim()) {
                    textRows.push(input.value.trim());
                }
            }
            
            // Get current palette and traits
            const palette = window.getCurrentPalette();
            const traits = window.calculateTraits();
            
            // Get current stripe data from the live sketch
            const currentStripeData = window.stripeData || [];
            
            try {
                // Create pure algorithm code with current state
                const pureAlgorithmCode = createPureAlgorithmCode(parseInt(seed), palette, currentStripeData, textRows);
                
                // Minify and obfuscate
                const minifiedCode = minifyCode(pureAlgorithmCode);
                const obfuscatedCode = obfuscateWithTamilLetters(minifiedCode);
                
                // Create self-contained NFT HTML with P5.js from CDN  
                let nftHTML = '<!DOCTYPE html>';
                nftHTML += '<html><head><meta charset="UTF-8">';
                nftHTML += '<title>Doormat NFT #' + seed + '</title>';
                nftHTML += '<style>';
                nftHTML += 'body{margin:0;padding:0;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:100vh;font-family:Arial,sans-serif}';
                nftHTML += 'canvas{border-radius:8px;box-shadow:0 4px 8px rgba(255,255,255,0.1)}';
                nftHTML += '.info{position:absolute;top:10px;left:10px;color:#fff;font-size:10px;opacity:0.7}';
                nftHTML += '.traits{position:absolute;top:10px;right:10px;color:#fff;font-size:8px;opacity:0.7;text-align:right}';
                nftHTML += '</style>';
                nftHTML += '<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></' + 'script>';
                nftHTML += '</head><body>';
                nftHTML += '<div class="info">Seed: ' + seed + '<br>Palette: ' + palette.name + '</div>';
                nftHTML += '<div class="traits">';
                nftHTML += Object.entries(traits).map(function(entry) { return entry[0] + ': ' + entry[1]; }).join('<br>');
                nftHTML += '</div>';
                nftHTML += '<div id="canvas-container"></div>';
                nftHTML += '<script>';
                nftHTML += obfuscatedCode;
                nftHTML += '</' + 'script>';
                nftHTML += '</body></html>';
                
                // Download the self-contained file
                const blob = new Blob([nftHTML], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'doormat-nft-' + seed + '.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('NFT file size:', Math.round(nftHTML.length / 1024) + 'KB');
                alert('NFT HTML exported! File size: ' + Math.round(nftHTML.length / 1024) + 'KB - ready for on-chain storage.');
                
            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
            }
        }
    </script>
</body>
</html>
